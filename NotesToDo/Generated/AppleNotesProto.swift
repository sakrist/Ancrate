// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: NotesToDo/Protos/apple_notes.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

///Represents a color
public struct Color: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var red: Float {
    get {return _red ?? 0}
    set {_red = newValue}
  }
  /// Returns true if `red` has been explicitly set.
  public var hasRed: Bool {return self._red != nil}
  /// Clears the value of `red`. Subsequent reads from it will return its default value.
  public mutating func clearRed() {self._red = nil}

  public var green: Float {
    get {return _green ?? 0}
    set {_green = newValue}
  }
  /// Returns true if `green` has been explicitly set.
  public var hasGreen: Bool {return self._green != nil}
  /// Clears the value of `green`. Subsequent reads from it will return its default value.
  public mutating func clearGreen() {self._green = nil}

  public var blue: Float {
    get {return _blue ?? 0}
    set {_blue = newValue}
  }
  /// Returns true if `blue` has been explicitly set.
  public var hasBlue: Bool {return self._blue != nil}
  /// Clears the value of `blue`. Subsequent reads from it will return its default value.
  public mutating func clearBlue() {self._blue = nil}

  public var alpha: Float {
    get {return _alpha ?? 0}
    set {_alpha = newValue}
  }
  /// Returns true if `alpha` has been explicitly set.
  public var hasAlpha: Bool {return self._alpha != nil}
  /// Clears the value of `alpha`. Subsequent reads from it will return its default value.
  public mutating func clearAlpha() {self._alpha = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _red: Float? = nil
  fileprivate var _green: Float? = nil
  fileprivate var _blue: Float? = nil
  fileprivate var _alpha: Float? = nil
}

/// Represents an attachment (embedded object)
public struct AttachmentInfo: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var attachmentIdentifier: String {
    get {return _attachmentIdentifier ?? String()}
    set {_attachmentIdentifier = newValue}
  }
  /// Returns true if `attachmentIdentifier` has been explicitly set.
  public var hasAttachmentIdentifier: Bool {return self._attachmentIdentifier != nil}
  /// Clears the value of `attachmentIdentifier`. Subsequent reads from it will return its default value.
  public mutating func clearAttachmentIdentifier() {self._attachmentIdentifier = nil}

  public var typeUti: String {
    get {return _typeUti ?? String()}
    set {_typeUti = newValue}
  }
  /// Returns true if `typeUti` has been explicitly set.
  public var hasTypeUti: Bool {return self._typeUti != nil}
  /// Clears the value of `typeUti`. Subsequent reads from it will return its default value.
  public mutating func clearTypeUti() {self._typeUti = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _attachmentIdentifier: String? = nil
  fileprivate var _typeUti: String? = nil
}

/// Represents a font
public struct Font: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var fontName: String {
    get {return _fontName ?? String()}
    set {_fontName = newValue}
  }
  /// Returns true if `fontName` has been explicitly set.
  public var hasFontName: Bool {return self._fontName != nil}
  /// Clears the value of `fontName`. Subsequent reads from it will return its default value.
  public mutating func clearFontName() {self._fontName = nil}

  public var pointSize: Float {
    get {return _pointSize ?? 0}
    set {_pointSize = newValue}
  }
  /// Returns true if `pointSize` has been explicitly set.
  public var hasPointSize: Bool {return self._pointSize != nil}
  /// Clears the value of `pointSize`. Subsequent reads from it will return its default value.
  public mutating func clearPointSize() {self._pointSize = nil}

  public var fontHints: Int32 {
    get {return _fontHints ?? 0}
    set {_fontHints = newValue}
  }
  /// Returns true if `fontHints` has been explicitly set.
  public var hasFontHints: Bool {return self._fontHints != nil}
  /// Clears the value of `fontHints`. Subsequent reads from it will return its default value.
  public mutating func clearFontHints() {self._fontHints = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _fontName: String? = nil
  fileprivate var _pointSize: Float? = nil
  fileprivate var _fontHints: Int32? = nil
}

/// Styles a "Paragraph" (any run of characters in an AttributeRun)
public struct ParagraphStyle: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var styleType: Int32 {
    get {return _styleType ?? -1}
    set {_styleType = newValue}
  }
  /// Returns true if `styleType` has been explicitly set.
  public var hasStyleType: Bool {return self._styleType != nil}
  /// Clears the value of `styleType`. Subsequent reads from it will return its default value.
  public mutating func clearStyleType() {self._styleType = nil}

  public var alignment: Int32 {
    get {return _alignment ?? 0}
    set {_alignment = newValue}
  }
  /// Returns true if `alignment` has been explicitly set.
  public var hasAlignment: Bool {return self._alignment != nil}
  /// Clears the value of `alignment`. Subsequent reads from it will return its default value.
  public mutating func clearAlignment() {self._alignment = nil}

  public var indentAmount: Int32 {
    get {return _indentAmount ?? 0}
    set {_indentAmount = newValue}
  }
  /// Returns true if `indentAmount` has been explicitly set.
  public var hasIndentAmount: Bool {return self._indentAmount != nil}
  /// Clears the value of `indentAmount`. Subsequent reads from it will return its default value.
  public mutating func clearIndentAmount() {self._indentAmount = nil}

  public var checklist: Checklist {
    get {return _checklist ?? Checklist()}
    set {_checklist = newValue}
  }
  /// Returns true if `checklist` has been explicitly set.
  public var hasChecklist: Bool {return self._checklist != nil}
  /// Clears the value of `checklist`. Subsequent reads from it will return its default value.
  public mutating func clearChecklist() {self._checklist = nil}

  public var blockQuote: Int32 {
    get {return _blockQuote ?? 0}
    set {_blockQuote = newValue}
  }
  /// Returns true if `blockQuote` has been explicitly set.
  public var hasBlockQuote: Bool {return self._blockQuote != nil}
  /// Clears the value of `blockQuote`. Subsequent reads from it will return its default value.
  public mutating func clearBlockQuote() {self._blockQuote = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _styleType: Int32? = nil
  fileprivate var _alignment: Int32? = nil
  fileprivate var _indentAmount: Int32? = nil
  fileprivate var _checklist: Checklist? = nil
  fileprivate var _blockQuote: Int32? = nil
}

/// Represents a checklist item
public struct Checklist: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var uuid: Data {
    get {return _uuid ?? Data()}
    set {_uuid = newValue}
  }
  /// Returns true if `uuid` has been explicitly set.
  public var hasUuid: Bool {return self._uuid != nil}
  /// Clears the value of `uuid`. Subsequent reads from it will return its default value.
  public mutating func clearUuid() {self._uuid = nil}

  public var done: Int32 {
    get {return _done ?? 0}
    set {_done = newValue}
  }
  /// Returns true if `done` has been explicitly set.
  public var hasDone: Bool {return self._done != nil}
  /// Clears the value of `done`. Subsequent reads from it will return its default value.
  public mutating func clearDone() {self._done = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _uuid: Data? = nil
  fileprivate var _done: Int32? = nil
}

/// Represents an object that has pointers to a key and a value, asserting 
/// somehow that the key object has to do with the value object.
public struct DictionaryElement: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var key: ObjectID {
    get {return _key ?? ObjectID()}
    set {_key = newValue}
  }
  /// Returns true if `key` has been explicitly set.
  public var hasKey: Bool {return self._key != nil}
  /// Clears the value of `key`. Subsequent reads from it will return its default value.
  public mutating func clearKey() {self._key = nil}

  public var value: ObjectID {
    get {return _value ?? ObjectID()}
    set {_value = newValue}
  }
  /// Returns true if `value` has been explicitly set.
  public var hasValue: Bool {return self._value != nil}
  /// Clears the value of `value`. Subsequent reads from it will return its default value.
  public mutating func clearValue() {self._value = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _key: ObjectID? = nil
  fileprivate var _value: ObjectID? = nil
}

/// A Dictionary holds many DictionaryElements
public struct Dictionary: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var element: [DictionaryElement] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// ObjectIDs are used to identify objects within the protobuf, offsets in an array, or 
/// a simple String.
public struct ObjectID: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unsignedIntegerValue: UInt64 {
    get {return _unsignedIntegerValue ?? 0}
    set {_unsignedIntegerValue = newValue}
  }
  /// Returns true if `unsignedIntegerValue` has been explicitly set.
  public var hasUnsignedIntegerValue: Bool {return self._unsignedIntegerValue != nil}
  /// Clears the value of `unsignedIntegerValue`. Subsequent reads from it will return its default value.
  public mutating func clearUnsignedIntegerValue() {self._unsignedIntegerValue = nil}

  public var stringValue: String {
    get {return _stringValue ?? String()}
    set {_stringValue = newValue}
  }
  /// Returns true if `stringValue` has been explicitly set.
  public var hasStringValue: Bool {return self._stringValue != nil}
  /// Clears the value of `stringValue`. Subsequent reads from it will return its default value.
  public mutating func clearStringValue() {self._stringValue = nil}

  public var objectIndex: Int32 {
    get {return _objectIndex ?? 0}
    set {_objectIndex = newValue}
  }
  /// Returns true if `objectIndex` has been explicitly set.
  public var hasObjectIndex: Bool {return self._objectIndex != nil}
  /// Clears the value of `objectIndex`. Subsequent reads from it will return its default value.
  public mutating func clearObjectIndex() {self._objectIndex = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _unsignedIntegerValue: UInt64? = nil
  fileprivate var _stringValue: String? = nil
  fileprivate var _objectIndex: Int32? = nil
}

/// Register Latest is used to identify the most recent version
public struct RegisterLatest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var contents: ObjectID {
    get {return _contents ?? ObjectID()}
    set {_contents = newValue}
  }
  /// Returns true if `contents` has been explicitly set.
  public var hasContents: Bool {return self._contents != nil}
  /// Clears the value of `contents`. Subsequent reads from it will return its default value.
  public mutating func clearContents() {self._contents = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _contents: ObjectID? = nil
}

/// MapEntries have a key that maps to an array of key items and a value that points to an object.
public struct MapEntry: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var key: Int32 {
    get {return _key ?? 0}
    set {_key = newValue}
  }
  /// Returns true if `key` has been explicitly set.
  public var hasKey: Bool {return self._key != nil}
  /// Clears the value of `key`. Subsequent reads from it will return its default value.
  public mutating func clearKey() {self._key = nil}

  public var value: ObjectID {
    get {return _value ?? ObjectID()}
    set {_value = newValue}
  }
  /// Returns true if `value` has been explicitly set.
  public var hasValue: Bool {return self._value != nil}
  /// Clears the value of `value`. Subsequent reads from it will return its default value.
  public mutating func clearValue() {self._value = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _key: Int32? = nil
  fileprivate var _value: ObjectID? = nil
}

/// Represents a "run" of characters that need to be styled/displayed/etc
public struct AttributeRun: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var length: Int32 {
    get {return _storage._length ?? 0}
    set {_uniqueStorage()._length = newValue}
  }
  /// Returns true if `length` has been explicitly set.
  public var hasLength: Bool {return _storage._length != nil}
  /// Clears the value of `length`. Subsequent reads from it will return its default value.
  public mutating func clearLength() {_uniqueStorage()._length = nil}

  public var paragraphStyle: ParagraphStyle {
    get {return _storage._paragraphStyle ?? ParagraphStyle()}
    set {_uniqueStorage()._paragraphStyle = newValue}
  }
  /// Returns true if `paragraphStyle` has been explicitly set.
  public var hasParagraphStyle: Bool {return _storage._paragraphStyle != nil}
  /// Clears the value of `paragraphStyle`. Subsequent reads from it will return its default value.
  public mutating func clearParagraphStyle() {_uniqueStorage()._paragraphStyle = nil}

  public var font: Font {
    get {return _storage._font ?? Font()}
    set {_uniqueStorage()._font = newValue}
  }
  /// Returns true if `font` has been explicitly set.
  public var hasFont: Bool {return _storage._font != nil}
  /// Clears the value of `font`. Subsequent reads from it will return its default value.
  public mutating func clearFont() {_uniqueStorage()._font = nil}

  public var fontWeight: Int32 {
    get {return _storage._fontWeight ?? 0}
    set {_uniqueStorage()._fontWeight = newValue}
  }
  /// Returns true if `fontWeight` has been explicitly set.
  public var hasFontWeight: Bool {return _storage._fontWeight != nil}
  /// Clears the value of `fontWeight`. Subsequent reads from it will return its default value.
  public mutating func clearFontWeight() {_uniqueStorage()._fontWeight = nil}

  public var underlined: Int32 {
    get {return _storage._underlined ?? 0}
    set {_uniqueStorage()._underlined = newValue}
  }
  /// Returns true if `underlined` has been explicitly set.
  public var hasUnderlined: Bool {return _storage._underlined != nil}
  /// Clears the value of `underlined`. Subsequent reads from it will return its default value.
  public mutating func clearUnderlined() {_uniqueStorage()._underlined = nil}

  public var strikethrough: Int32 {
    get {return _storage._strikethrough ?? 0}
    set {_uniqueStorage()._strikethrough = newValue}
  }
  /// Returns true if `strikethrough` has been explicitly set.
  public var hasStrikethrough: Bool {return _storage._strikethrough != nil}
  /// Clears the value of `strikethrough`. Subsequent reads from it will return its default value.
  public mutating func clearStrikethrough() {_uniqueStorage()._strikethrough = nil}

  ///Sign indicates super/sub
  public var superscript: Int32 {
    get {return _storage._superscript ?? 0}
    set {_uniqueStorage()._superscript = newValue}
  }
  /// Returns true if `superscript` has been explicitly set.
  public var hasSuperscript: Bool {return _storage._superscript != nil}
  /// Clears the value of `superscript`. Subsequent reads from it will return its default value.
  public mutating func clearSuperscript() {_uniqueStorage()._superscript = nil}

  public var link: String {
    get {return _storage._link ?? String()}
    set {_uniqueStorage()._link = newValue}
  }
  /// Returns true if `link` has been explicitly set.
  public var hasLink: Bool {return _storage._link != nil}
  /// Clears the value of `link`. Subsequent reads from it will return its default value.
  public mutating func clearLink() {_uniqueStorage()._link = nil}

  public var color: Color {
    get {return _storage._color ?? Color()}
    set {_uniqueStorage()._color = newValue}
  }
  /// Returns true if `color` has been explicitly set.
  public var hasColor: Bool {return _storage._color != nil}
  /// Clears the value of `color`. Subsequent reads from it will return its default value.
  public mutating func clearColor() {_uniqueStorage()._color = nil}

  public var attachmentInfo: AttachmentInfo {
    get {return _storage._attachmentInfo ?? AttachmentInfo()}
    set {_uniqueStorage()._attachmentInfo = newValue}
  }
  /// Returns true if `attachmentInfo` has been explicitly set.
  public var hasAttachmentInfo: Bool {return _storage._attachmentInfo != nil}
  /// Clears the value of `attachmentInfo`. Subsequent reads from it will return its default value.
  public mutating func clearAttachmentInfo() {_uniqueStorage()._attachmentInfo = nil}

  public var unknownIdentifier: Int32 {
    get {return _storage._unknownIdentifier ?? 0}
    set {_uniqueStorage()._unknownIdentifier = newValue}
  }
  /// Returns true if `unknownIdentifier` has been explicitly set.
  public var hasUnknownIdentifier: Bool {return _storage._unknownIdentifier != nil}
  /// Clears the value of `unknownIdentifier`. Subsequent reads from it will return its default value.
  public mutating func clearUnknownIdentifier() {_uniqueStorage()._unknownIdentifier = nil}

  public var emphasisStyle: Int32 {
    get {return _storage._emphasisStyle ?? 0}
    set {_uniqueStorage()._emphasisStyle = newValue}
  }
  /// Returns true if `emphasisStyle` has been explicitly set.
  public var hasEmphasisStyle: Bool {return _storage._emphasisStyle != nil}
  /// Clears the value of `emphasisStyle`. Subsequent reads from it will return its default value.
  public mutating func clearEmphasisStyle() {_uniqueStorage()._emphasisStyle = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Overarching object in a ZNOTEDATA.ZDATA blob
public struct NoteStoreProto: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var document: Document {
    get {return _document ?? Document()}
    set {_document = newValue}
  }
  /// Returns true if `document` has been explicitly set.
  public var hasDocument: Bool {return self._document != nil}
  /// Clears the value of `document`. Subsequent reads from it will return its default value.
  public mutating func clearDocument() {self._document = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _document: Document? = nil
}

/// A Document has a Note within it.
public struct Document: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var version: Int32 {
    get {return _version ?? 0}
    set {_version = newValue}
  }
  /// Returns true if `version` has been explicitly set.
  public var hasVersion: Bool {return self._version != nil}
  /// Clears the value of `version`. Subsequent reads from it will return its default value.
  public mutating func clearVersion() {self._version = nil}

  public var note: Note {
    get {return _note ?? Note()}
    set {_note = newValue}
  }
  /// Returns true if `note` has been explicitly set.
  public var hasNote: Bool {return self._note != nil}
  /// Clears the value of `note`. Subsequent reads from it will return its default value.
  public mutating func clearNote() {self._note = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _version: Int32? = nil
  fileprivate var _note: Note? = nil
}

/// A Note has both text, and then a lot of formatting entries.
/// Other fields are present and not yet included in this proto.
public struct Note: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var noteText: String {
    get {return _noteText ?? String()}
    set {_noteText = newValue}
  }
  /// Returns true if `noteText` has been explicitly set.
  public var hasNoteText: Bool {return self._noteText != nil}
  /// Clears the value of `noteText`. Subsequent reads from it will return its default value.
  public mutating func clearNoteText() {self._noteText = nil}

  public var attributeRun: [AttributeRun] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _noteText: String? = nil
}

/// Represents the top level object in a ZMERGEABLEDATA cell
public struct MergableDataProto: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var mergableDataObject: MergableDataObject {
    get {return _mergableDataObject ?? MergableDataObject()}
    set {_mergableDataObject = newValue}
  }
  /// Returns true if `mergableDataObject` has been explicitly set.
  public var hasMergableDataObject: Bool {return self._mergableDataObject != nil}
  /// Clears the value of `mergableDataObject`. Subsequent reads from it will return its default value.
  public mutating func clearMergableDataObject() {self._mergableDataObject = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _mergableDataObject: MergableDataObject? = nil
}

/// Similar to Document for Notes, this is what holds the mergeable object
public struct MergableDataObject: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Asserted to be version in https://github.com/dunhamsteve/notesutils
  public var version: Int32 {
    get {return _version ?? 0}
    set {_version = newValue}
  }
  /// Returns true if `version` has been explicitly set.
  public var hasVersion: Bool {return self._version != nil}
  /// Clears the value of `version`. Subsequent reads from it will return its default value.
  public mutating func clearVersion() {self._version = nil}

  public var mergeableDataObjectData: MergeableDataObjectData {
    get {return _mergeableDataObjectData ?? MergeableDataObjectData()}
    set {_mergeableDataObjectData = newValue}
  }
  /// Returns true if `mergeableDataObjectData` has been explicitly set.
  public var hasMergeableDataObjectData: Bool {return self._mergeableDataObjectData != nil}
  /// Clears the value of `mergeableDataObjectData`. Subsequent reads from it will return its default value.
  public mutating func clearMergeableDataObjectData() {self._mergeableDataObjectData = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _version: Int32? = nil
  fileprivate var _mergeableDataObjectData: MergeableDataObjectData? = nil
}

/// This is the mergeable data object itself and has a lot of entries that are the parts of it 
/// along with arrays of key, type, and UUID items, depending on type.
public struct MergeableDataObjectData: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var mergeableDataObjectEntry: [MergeableDataObjectEntry] = []

  public var mergeableDataObjectKeyItem: [String] = []

  public var mergeableDataObjectTypeItem: [String] = []

  public var mergeableDataObjectUuidItem: [Data] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Each entry is part of the object. For example, one entry might be identifying which
/// UUIDs are rows, and another might hold the text of a cell.
public struct MergeableDataObjectEntry: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var registerLatest: RegisterLatest {
    get {return _registerLatest ?? RegisterLatest()}
    set {_registerLatest = newValue}
  }
  /// Returns true if `registerLatest` has been explicitly set.
  public var hasRegisterLatest: Bool {return self._registerLatest != nil}
  /// Clears the value of `registerLatest`. Subsequent reads from it will return its default value.
  public mutating func clearRegisterLatest() {self._registerLatest = nil}

  public var list: List {
    get {return _list ?? List()}
    set {_list = newValue}
  }
  /// Returns true if `list` has been explicitly set.
  public var hasList: Bool {return self._list != nil}
  /// Clears the value of `list`. Subsequent reads from it will return its default value.
  public mutating func clearList() {self._list = nil}

  public var dictionary: Dictionary {
    get {return _dictionary ?? Dictionary()}
    set {_dictionary = newValue}
  }
  /// Returns true if `dictionary` has been explicitly set.
  public var hasDictionary: Bool {return self._dictionary != nil}
  /// Clears the value of `dictionary`. Subsequent reads from it will return its default value.
  public mutating func clearDictionary() {self._dictionary = nil}

  public var unknownMessage: UnknownMergeableDataObjectEntryMessage {
    get {return _unknownMessage ?? UnknownMergeableDataObjectEntryMessage()}
    set {_unknownMessage = newValue}
  }
  /// Returns true if `unknownMessage` has been explicitly set.
  public var hasUnknownMessage: Bool {return self._unknownMessage != nil}
  /// Clears the value of `unknownMessage`. Subsequent reads from it will return its default value.
  public mutating func clearUnknownMessage() {self._unknownMessage = nil}

  public var note: Note {
    get {return _note ?? Note()}
    set {_note = newValue}
  }
  /// Returns true if `note` has been explicitly set.
  public var hasNote: Bool {return self._note != nil}
  /// Clears the value of `note`. Subsequent reads from it will return its default value.
  public mutating func clearNote() {self._note = nil}

  public var customMap: MergeableDataObjectMap {
    get {return _customMap ?? MergeableDataObjectMap()}
    set {_customMap = newValue}
  }
  /// Returns true if `customMap` has been explicitly set.
  public var hasCustomMap: Bool {return self._customMap != nil}
  /// Clears the value of `customMap`. Subsequent reads from it will return its default value.
  public mutating func clearCustomMap() {self._customMap = nil}

  public var orderedSet: OrderedSet {
    get {return _orderedSet ?? OrderedSet()}
    set {_orderedSet = newValue}
  }
  /// Returns true if `orderedSet` has been explicitly set.
  public var hasOrderedSet: Bool {return self._orderedSet != nil}
  /// Clears the value of `orderedSet`. Subsequent reads from it will return its default value.
  public mutating func clearOrderedSet() {self._orderedSet = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _registerLatest: RegisterLatest? = nil
  fileprivate var _list: List? = nil
  fileprivate var _dictionary: Dictionary? = nil
  fileprivate var _unknownMessage: UnknownMergeableDataObjectEntryMessage? = nil
  fileprivate var _note: Note? = nil
  fileprivate var _customMap: MergeableDataObjectMap? = nil
  fileprivate var _orderedSet: OrderedSet? = nil
}

/// This is unknown, it first was noticed in folder order analysis.
public struct UnknownMergeableDataObjectEntryMessage: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownEntry: UnknownMergeableDataObjectEntryMessageEntry {
    get {return _unknownEntry ?? UnknownMergeableDataObjectEntryMessageEntry()}
    set {_unknownEntry = newValue}
  }
  /// Returns true if `unknownEntry` has been explicitly set.
  public var hasUnknownEntry: Bool {return self._unknownEntry != nil}
  /// Clears the value of `unknownEntry`. Subsequent reads from it will return its default value.
  public mutating func clearUnknownEntry() {self._unknownEntry = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _unknownEntry: UnknownMergeableDataObjectEntryMessageEntry? = nil
}

/// This is unknown, it first was noticed in folder order analysis.
/// "unknown_int2" is where the folder order is stored
public struct UnknownMergeableDataObjectEntryMessageEntry: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownInt1: Int32 {
    get {return _unknownInt1 ?? 0}
    set {_unknownInt1 = newValue}
  }
  /// Returns true if `unknownInt1` has been explicitly set.
  public var hasUnknownInt1: Bool {return self._unknownInt1 != nil}
  /// Clears the value of `unknownInt1`. Subsequent reads from it will return its default value.
  public mutating func clearUnknownInt1() {self._unknownInt1 = nil}

  public var unknownInt2: Int64 {
    get {return _unknownInt2 ?? 0}
    set {_unknownInt2 = newValue}
  }
  /// Returns true if `unknownInt2` has been explicitly set.
  public var hasUnknownInt2: Bool {return self._unknownInt2 != nil}
  /// Clears the value of `unknownInt2`. Subsequent reads from it will return its default value.
  public mutating func clearUnknownInt2() {self._unknownInt2 = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _unknownInt1: Int32? = nil
  fileprivate var _unknownInt2: Int64? = nil
}

/// The Object Map uses its type to identify what you are looking at and 
/// then a map entry to do something with that value.
public struct MergeableDataObjectMap: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var type: Int32 {
    get {return _type ?? 0}
    set {_type = newValue}
  }
  /// Returns true if `type` has been explicitly set.
  public var hasType: Bool {return self._type != nil}
  /// Clears the value of `type`. Subsequent reads from it will return its default value.
  public mutating func clearType() {self._type = nil}

  public var mapEntry: [MapEntry] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _type: Int32? = nil
}

/// An ordered set is used to hold structural information for embedded tables
public struct OrderedSet: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var ordering: OrderedSetOrdering {
    get {return _ordering ?? OrderedSetOrdering()}
    set {_ordering = newValue}
  }
  /// Returns true if `ordering` has been explicitly set.
  public var hasOrdering: Bool {return self._ordering != nil}
  /// Clears the value of `ordering`. Subsequent reads from it will return its default value.
  public mutating func clearOrdering() {self._ordering = nil}

  public var elements: Dictionary {
    get {return _elements ?? Dictionary()}
    set {_elements = newValue}
  }
  /// Returns true if `elements` has been explicitly set.
  public var hasElements: Bool {return self._elements != nil}
  /// Clears the value of `elements`. Subsequent reads from it will return its default value.
  public mutating func clearElements() {self._elements = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _ordering: OrderedSetOrdering? = nil
  fileprivate var _elements: Dictionary? = nil
}

/// The ordered set ordering identifies rows and columns in embedded tables, with an array 
/// of the objects and contents that map lookup values to originals.
public struct OrderedSetOrdering: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var array: OrderedSetOrderingArray {
    get {return _array ?? OrderedSetOrderingArray()}
    set {_array = newValue}
  }
  /// Returns true if `array` has been explicitly set.
  public var hasArray: Bool {return self._array != nil}
  /// Clears the value of `array`. Subsequent reads from it will return its default value.
  public mutating func clearArray() {self._array = nil}

  public var contents: Dictionary {
    get {return _contents ?? Dictionary()}
    set {_contents = newValue}
  }
  /// Returns true if `contents` has been explicitly set.
  public var hasContents: Bool {return self._contents != nil}
  /// Clears the value of `contents`. Subsequent reads from it will return its default value.
  public mutating func clearContents() {self._contents = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _array: OrderedSetOrderingArray? = nil
  fileprivate var _contents: Dictionary? = nil
}

/// This array holds both the text to replace and the array of UUIDs to tell what
/// embedded rows and columns are.
public struct OrderedSetOrderingArray: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var contents: Note {
    get {return _contents ?? Note()}
    set {_contents = newValue}
  }
  /// Returns true if `contents` has been explicitly set.
  public var hasContents: Bool {return self._contents != nil}
  /// Clears the value of `contents`. Subsequent reads from it will return its default value.
  public mutating func clearContents() {self._contents = nil}

  public var attachment: [OrderedSetOrderingArrayAttachment] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _contents: Note? = nil
}

/// This array identifies the UUIDs that are embedded table rows or columns
public struct OrderedSetOrderingArrayAttachment: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var index: Int32 {
    get {return _index ?? 0}
    set {_index = newValue}
  }
  /// Returns true if `index` has been explicitly set.
  public var hasIndex: Bool {return self._index != nil}
  /// Clears the value of `index`. Subsequent reads from it will return its default value.
  public mutating func clearIndex() {self._index = nil}

  public var uuid: Data {
    get {return _uuid ?? Data()}
    set {_uuid = newValue}
  }
  /// Returns true if `uuid` has been explicitly set.
  public var hasUuid: Bool {return self._uuid != nil}
  /// Clears the value of `uuid`. Subsequent reads from it will return its default value.
  public mutating func clearUuid() {self._uuid = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _index: Int32? = nil
  fileprivate var _uuid: Data? = nil
}

/// A List holds details about multiple objects
public struct List: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var listEntry: [ListEntry] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// A list Entry holds details about a specific object
public struct ListEntry: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: ObjectID {
    get {return _id ?? ObjectID()}
    set {_id = newValue}
  }
  /// Returns true if `id` has been explicitly set.
  public var hasID: Bool {return self._id != nil}
  /// Clears the value of `id`. Subsequent reads from it will return its default value.
  public mutating func clearID() {self._id = nil}

  /// I dislike this naming, but don't have better information
  public var details: ListEntryDetails {
    get {return _details ?? ListEntryDetails()}
    set {_details = newValue}
  }
  /// Returns true if `details` has been explicitly set.
  public var hasDetails: Bool {return self._details != nil}
  /// Clears the value of `details`. Subsequent reads from it will return its default value.
  public mutating func clearDetails() {self._details = nil}

  public var additionalDetails: ListEntryDetails {
    get {return _additionalDetails ?? ListEntryDetails()}
    set {_additionalDetails = newValue}
  }
  /// Returns true if `additionalDetails` has been explicitly set.
  public var hasAdditionalDetails: Bool {return self._additionalDetails != nil}
  /// Clears the value of `additionalDetails`. Subsequent reads from it will return its default value.
  public mutating func clearAdditionalDetails() {self._additionalDetails = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _id: ObjectID? = nil
  fileprivate var _details: ListEntryDetails? = nil
  fileprivate var _additionalDetails: ListEntryDetails? = nil
}

/// List Entry Details hold another object ID and unidentified mapping
public struct ListEntryDetails: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var listEntryDetailsKey: ListEntryDetailsKey {
    get {return _listEntryDetailsKey ?? ListEntryDetailsKey()}
    set {_listEntryDetailsKey = newValue}
  }
  /// Returns true if `listEntryDetailsKey` has been explicitly set.
  public var hasListEntryDetailsKey: Bool {return self._listEntryDetailsKey != nil}
  /// Clears the value of `listEntryDetailsKey`. Subsequent reads from it will return its default value.
  public mutating func clearListEntryDetailsKey() {self._listEntryDetailsKey = nil}

  public var id: ObjectID {
    get {return _id ?? ObjectID()}
    set {_id = newValue}
  }
  /// Returns true if `id` has been explicitly set.
  public var hasID: Bool {return self._id != nil}
  /// Clears the value of `id`. Subsequent reads from it will return its default value.
  public mutating func clearID() {self._id = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _listEntryDetailsKey: ListEntryDetailsKey? = nil
  fileprivate var _id: ObjectID? = nil
}

public struct ListEntryDetailsKey: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var listEntryDetailsTypeIndex: Int32 {
    get {return _listEntryDetailsTypeIndex ?? 0}
    set {_listEntryDetailsTypeIndex = newValue}
  }
  /// Returns true if `listEntryDetailsTypeIndex` has been explicitly set.
  public var hasListEntryDetailsTypeIndex: Bool {return self._listEntryDetailsTypeIndex != nil}
  /// Clears the value of `listEntryDetailsTypeIndex`. Subsequent reads from it will return its default value.
  public mutating func clearListEntryDetailsTypeIndex() {self._listEntryDetailsTypeIndex = nil}

  public var listEntryDetailsKey: Int32 {
    get {return _listEntryDetailsKey ?? 0}
    set {_listEntryDetailsKey = newValue}
  }
  /// Returns true if `listEntryDetailsKey` has been explicitly set.
  public var hasListEntryDetailsKey: Bool {return self._listEntryDetailsKey != nil}
  /// Clears the value of `listEntryDetailsKey`. Subsequent reads from it will return its default value.
  public mutating func clearListEntryDetailsKey() {self._listEntryDetailsKey = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _listEntryDetailsTypeIndex: Int32? = nil
  fileprivate var _listEntryDetailsKey: Int32? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

extension Color: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "Color"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}red\0\u{1}green\0\u{1}blue\0\u{1}alpha\0")

  public var isInitialized: Bool {
    if self._red == nil {return false}
    if self._green == nil {return false}
    if self._blue == nil {return false}
    if self._alpha == nil {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFloatField(value: &self._red) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self._green) }()
      case 3: try { try decoder.decodeSingularFloatField(value: &self._blue) }()
      case 4: try { try decoder.decodeSingularFloatField(value: &self._alpha) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._red {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._green {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._blue {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._alpha {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Color, rhs: Color) -> Bool {
    if lhs._red != rhs._red {return false}
    if lhs._green != rhs._green {return false}
    if lhs._blue != rhs._blue {return false}
    if lhs._alpha != rhs._alpha {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension AttachmentInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "AttachmentInfo"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}attachment_identifier\0\u{3}type_uti\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._attachmentIdentifier) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._typeUti) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._attachmentIdentifier {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._typeUti {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: AttachmentInfo, rhs: AttachmentInfo) -> Bool {
    if lhs._attachmentIdentifier != rhs._attachmentIdentifier {return false}
    if lhs._typeUti != rhs._typeUti {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Font: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "Font"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}font_name\0\u{3}point_size\0\u{3}font_hints\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._fontName) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self._pointSize) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self._fontHints) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._fontName {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._pointSize {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._fontHints {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Font, rhs: Font) -> Bool {
    if lhs._fontName != rhs._fontName {return false}
    if lhs._pointSize != rhs._pointSize {return false}
    if lhs._fontHints != rhs._fontHints {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ParagraphStyle: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "ParagraphStyle"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}style_type\0\u{1}alignment\0\u{4}\u{2}indent_amount\0\u{1}checklist\0\u{4}\u{3}block_quote\0")

  public var isInitialized: Bool {
    if let v = self._checklist, !v.isInitialized {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self._styleType) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self._alignment) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self._indentAmount) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._checklist) }()
      case 8: try { try decoder.decodeSingularInt32Field(value: &self._blockQuote) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._styleType {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._alignment {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._indentAmount {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._checklist {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._blockQuote {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 8)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ParagraphStyle, rhs: ParagraphStyle) -> Bool {
    if lhs._styleType != rhs._styleType {return false}
    if lhs._alignment != rhs._alignment {return false}
    if lhs._indentAmount != rhs._indentAmount {return false}
    if lhs._checklist != rhs._checklist {return false}
    if lhs._blockQuote != rhs._blockQuote {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Checklist: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "Checklist"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}uuid\0\u{1}done\0")

  public var isInitialized: Bool {
    if self._uuid == nil {return false}
    if self._done == nil {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self._uuid) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self._done) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._uuid {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._done {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Checklist, rhs: Checklist) -> Bool {
    if lhs._uuid != rhs._uuid {return false}
    if lhs._done != rhs._done {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension DictionaryElement: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "DictionaryElement"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}key\0\u{1}value\0")

  public var isInitialized: Bool {
    if self._key == nil {return false}
    if self._value == nil {return false}
    if let v = self._key, !v.isInitialized {return false}
    if let v = self._value, !v.isInitialized {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._key) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._value) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._key {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._value {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: DictionaryElement, rhs: DictionaryElement) -> Bool {
    if lhs._key != rhs._key {return false}
    if lhs._value != rhs._value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Dictionary: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "Dictionary"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}element\0")

  public var isInitialized: Bool {
    if !SwiftProtobuf.Internal.areAllInitialized(self.element) {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.element) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.element.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.element, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Dictionary, rhs: Dictionary) -> Bool {
    if lhs.element != rhs.element {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ObjectID: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "ObjectID"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{4}\u{2}unsigned_integer_value\0\u{4}\u{2}string_value\0\u{4}\u{2}object_index\0")

  public var isInitialized: Bool {
    if self._unsignedIntegerValue == nil {return false}
    if self._stringValue == nil {return false}
    if self._objectIndex == nil {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self._unsignedIntegerValue) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self._stringValue) }()
      case 6: try { try decoder.decodeSingularInt32Field(value: &self._objectIndex) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._unsignedIntegerValue {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._stringValue {
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._objectIndex {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 6)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ObjectID, rhs: ObjectID) -> Bool {
    if lhs._unsignedIntegerValue != rhs._unsignedIntegerValue {return false}
    if lhs._stringValue != rhs._stringValue {return false}
    if lhs._objectIndex != rhs._objectIndex {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RegisterLatest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "RegisterLatest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\u{2}contents\0")

  public var isInitialized: Bool {
    if self._contents == nil {return false}
    if let v = self._contents, !v.isInitialized {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularMessageField(value: &self._contents) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._contents {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: RegisterLatest, rhs: RegisterLatest) -> Bool {
    if lhs._contents != rhs._contents {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MapEntry: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "MapEntry"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}key\0\u{1}value\0")

  public var isInitialized: Bool {
    if self._key == nil {return false}
    if self._value == nil {return false}
    if let v = self._value, !v.isInitialized {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self._key) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._value) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._key {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._value {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MapEntry, rhs: MapEntry) -> Bool {
    if lhs._key != rhs._key {return false}
    if lhs._value != rhs._value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension AttributeRun: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "AttributeRun"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}length\0\u{3}paragraph_style\0\u{1}font\0\u{4}\u{2}font_weight\0\u{1}underlined\0\u{1}strikethrough\0\u{1}superscript\0\u{1}link\0\u{1}color\0\u{4}\u{2}attachment_info\0\u{3}unknown_identifier\0\u{3}emphasis_style\0")

  fileprivate class _StorageClass {
    var _length: Int32? = nil
    var _paragraphStyle: ParagraphStyle? = nil
    var _font: Font? = nil
    var _fontWeight: Int32? = nil
    var _underlined: Int32? = nil
    var _strikethrough: Int32? = nil
    var _superscript: Int32? = nil
    var _link: String? = nil
    var _color: Color? = nil
    var _attachmentInfo: AttachmentInfo? = nil
    var _unknownIdentifier: Int32? = nil
    var _emphasisStyle: Int32? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _length = source._length
      _paragraphStyle = source._paragraphStyle
      _font = source._font
      _fontWeight = source._fontWeight
      _underlined = source._underlined
      _strikethrough = source._strikethrough
      _superscript = source._superscript
      _link = source._link
      _color = source._color
      _attachmentInfo = source._attachmentInfo
      _unknownIdentifier = source._unknownIdentifier
      _emphasisStyle = source._emphasisStyle
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._length == nil {return false}
      if let v = _storage._paragraphStyle, !v.isInitialized {return false}
      if let v = _storage._color, !v.isInitialized {return false}
      return true
    }
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularInt32Field(value: &_storage._length) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._paragraphStyle) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._font) }()
        case 5: try { try decoder.decodeSingularInt32Field(value: &_storage._fontWeight) }()
        case 6: try { try decoder.decodeSingularInt32Field(value: &_storage._underlined) }()
        case 7: try { try decoder.decodeSingularInt32Field(value: &_storage._strikethrough) }()
        case 8: try { try decoder.decodeSingularInt32Field(value: &_storage._superscript) }()
        case 9: try { try decoder.decodeSingularStringField(value: &_storage._link) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._color) }()
        case 12: try { try decoder.decodeSingularMessageField(value: &_storage._attachmentInfo) }()
        case 13: try { try decoder.decodeSingularInt32Field(value: &_storage._unknownIdentifier) }()
        case 14: try { try decoder.decodeSingularInt32Field(value: &_storage._emphasisStyle) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._length {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._paragraphStyle {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._font {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._fontWeight {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._underlined {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._strikethrough {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._superscript {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._link {
        try visitor.visitSingularStringField(value: v, fieldNumber: 9)
      } }()
      try { if let v = _storage._color {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      } }()
      try { if let v = _storage._attachmentInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      } }()
      try { if let v = _storage._unknownIdentifier {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 13)
      } }()
      try { if let v = _storage._emphasisStyle {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 14)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: AttributeRun, rhs: AttributeRun) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._length != rhs_storage._length {return false}
        if _storage._paragraphStyle != rhs_storage._paragraphStyle {return false}
        if _storage._font != rhs_storage._font {return false}
        if _storage._fontWeight != rhs_storage._fontWeight {return false}
        if _storage._underlined != rhs_storage._underlined {return false}
        if _storage._strikethrough != rhs_storage._strikethrough {return false}
        if _storage._superscript != rhs_storage._superscript {return false}
        if _storage._link != rhs_storage._link {return false}
        if _storage._color != rhs_storage._color {return false}
        if _storage._attachmentInfo != rhs_storage._attachmentInfo {return false}
        if _storage._unknownIdentifier != rhs_storage._unknownIdentifier {return false}
        if _storage._emphasisStyle != rhs_storage._emphasisStyle {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension NoteStoreProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "NoteStoreProto"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\u{2}document\0")

  public var isInitialized: Bool {
    if self._document == nil {return false}
    if let v = self._document, !v.isInitialized {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularMessageField(value: &self._document) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._document {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: NoteStoreProto, rhs: NoteStoreProto) -> Bool {
    if lhs._document != rhs._document {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Document: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "Document"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\u{2}version\0\u{1}note\0")

  public var isInitialized: Bool {
    if self._version == nil {return false}
    if self._note == nil {return false}
    if let v = self._note, !v.isInitialized {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularInt32Field(value: &self._version) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._note) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._version {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._note {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Document, rhs: Document) -> Bool {
    if lhs._version != rhs._version {return false}
    if lhs._note != rhs._note {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Note: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "Note"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{4}\u{2}note_text\0\u{4}\u{3}attribute_run\0")

  public var isInitialized: Bool {
    if self._noteText == nil {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.attributeRun) {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularStringField(value: &self._noteText) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.attributeRun) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._noteText {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    if !self.attributeRun.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.attributeRun, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Note, rhs: Note) -> Bool {
    if lhs._noteText != rhs._noteText {return false}
    if lhs.attributeRun != rhs.attributeRun {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MergableDataProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "MergableDataProto"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{4}\u{2}mergable_data_object\0")

  public var isInitialized: Bool {
    if self._mergableDataObject == nil {return false}
    if let v = self._mergableDataObject, !v.isInitialized {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularMessageField(value: &self._mergableDataObject) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._mergableDataObject {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MergableDataProto, rhs: MergableDataProto) -> Bool {
    if lhs._mergableDataObject != rhs._mergableDataObject {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MergableDataObject: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "MergableDataObject"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\u{2}version\0\u{3}mergeable_data_object_data\0")

  public var isInitialized: Bool {
    if self._version == nil {return false}
    if self._mergeableDataObjectData == nil {return false}
    if let v = self._mergeableDataObjectData, !v.isInitialized {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularInt32Field(value: &self._version) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._mergeableDataObjectData) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._version {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._mergeableDataObjectData {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MergableDataObject, rhs: MergableDataObject) -> Bool {
    if lhs._version != rhs._version {return false}
    if lhs._mergeableDataObjectData != rhs._mergeableDataObjectData {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MergeableDataObjectData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "MergeableDataObjectData"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{4}\u{3}mergeable_data_object_entry\0\u{3}mergeable_data_object_key_item\0\u{3}mergeable_data_object_type_item\0\u{3}mergeable_data_object_uuid_item\0")

  public var isInitialized: Bool {
    if !SwiftProtobuf.Internal.areAllInitialized(self.mergeableDataObjectEntry) {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.mergeableDataObjectEntry) }()
      case 4: try { try decoder.decodeRepeatedStringField(value: &self.mergeableDataObjectKeyItem) }()
      case 5: try { try decoder.decodeRepeatedStringField(value: &self.mergeableDataObjectTypeItem) }()
      case 6: try { try decoder.decodeRepeatedBytesField(value: &self.mergeableDataObjectUuidItem) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.mergeableDataObjectEntry.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.mergeableDataObjectEntry, fieldNumber: 3)
    }
    if !self.mergeableDataObjectKeyItem.isEmpty {
      try visitor.visitRepeatedStringField(value: self.mergeableDataObjectKeyItem, fieldNumber: 4)
    }
    if !self.mergeableDataObjectTypeItem.isEmpty {
      try visitor.visitRepeatedStringField(value: self.mergeableDataObjectTypeItem, fieldNumber: 5)
    }
    if !self.mergeableDataObjectUuidItem.isEmpty {
      try visitor.visitRepeatedBytesField(value: self.mergeableDataObjectUuidItem, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MergeableDataObjectData, rhs: MergeableDataObjectData) -> Bool {
    if lhs.mergeableDataObjectEntry != rhs.mergeableDataObjectEntry {return false}
    if lhs.mergeableDataObjectKeyItem != rhs.mergeableDataObjectKeyItem {return false}
    if lhs.mergeableDataObjectTypeItem != rhs.mergeableDataObjectTypeItem {return false}
    if lhs.mergeableDataObjectUuidItem != rhs.mergeableDataObjectUuidItem {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MergeableDataObjectEntry: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "MergeableDataObjectEntry"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}register_latest\0\u{2}\u{4}list\0\u{1}dictionary\0\u{4}\u{3}unknown_message\0\u{1}note\0\u{4}\u{3}custom_map\0\u{4}\u{3}ordered_set\0")

  public var isInitialized: Bool {
    if self._registerLatest == nil {return false}
    if let v = self._registerLatest, !v.isInitialized {return false}
    if let v = self._list, !v.isInitialized {return false}
    if let v = self._dictionary, !v.isInitialized {return false}
    if let v = self._note, !v.isInitialized {return false}
    if let v = self._customMap, !v.isInitialized {return false}
    if let v = self._orderedSet, !v.isInitialized {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._registerLatest) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._list) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._dictionary) }()
      case 9: try { try decoder.decodeSingularMessageField(value: &self._unknownMessage) }()
      case 10: try { try decoder.decodeSingularMessageField(value: &self._note) }()
      case 13: try { try decoder.decodeSingularMessageField(value: &self._customMap) }()
      case 16: try { try decoder.decodeSingularMessageField(value: &self._orderedSet) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._registerLatest {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._list {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._dictionary {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._unknownMessage {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    } }()
    try { if let v = self._note {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    } }()
    try { if let v = self._customMap {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
    } }()
    try { if let v = self._orderedSet {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MergeableDataObjectEntry, rhs: MergeableDataObjectEntry) -> Bool {
    if lhs._registerLatest != rhs._registerLatest {return false}
    if lhs._list != rhs._list {return false}
    if lhs._dictionary != rhs._dictionary {return false}
    if lhs._unknownMessage != rhs._unknownMessage {return false}
    if lhs._note != rhs._note {return false}
    if lhs._customMap != rhs._customMap {return false}
    if lhs._orderedSet != rhs._orderedSet {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension UnknownMergeableDataObjectEntryMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "UnknownMergeableDataObjectEntryMessage"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}unknown_entry\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._unknownEntry) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._unknownEntry {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: UnknownMergeableDataObjectEntryMessage, rhs: UnknownMergeableDataObjectEntryMessage) -> Bool {
    if lhs._unknownEntry != rhs._unknownEntry {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension UnknownMergeableDataObjectEntryMessageEntry: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "UnknownMergeableDataObjectEntryMessageEntry"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}unknown_int1\0\u{3}unknown_int2\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self._unknownInt1) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self._unknownInt2) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._unknownInt1 {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._unknownInt2 {
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: UnknownMergeableDataObjectEntryMessageEntry, rhs: UnknownMergeableDataObjectEntryMessageEntry) -> Bool {
    if lhs._unknownInt1 != rhs._unknownInt1 {return false}
    if lhs._unknownInt2 != rhs._unknownInt2 {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MergeableDataObjectMap: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "MergeableDataObjectMap"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}type\0\u{4}\u{2}map_entry\0")

  public var isInitialized: Bool {
    if self._type == nil {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.mapEntry) {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self._type) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.mapEntry) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._type {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    if !self.mapEntry.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.mapEntry, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MergeableDataObjectMap, rhs: MergeableDataObjectMap) -> Bool {
    if lhs._type != rhs._type {return false}
    if lhs.mapEntry != rhs.mapEntry {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OrderedSet: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "OrderedSet"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}ordering\0\u{1}elements\0")

  public var isInitialized: Bool {
    if self._ordering == nil {return false}
    if self._elements == nil {return false}
    if let v = self._ordering, !v.isInitialized {return false}
    if let v = self._elements, !v.isInitialized {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._ordering) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._elements) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._ordering {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._elements {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OrderedSet, rhs: OrderedSet) -> Bool {
    if lhs._ordering != rhs._ordering {return false}
    if lhs._elements != rhs._elements {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OrderedSetOrdering: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "OrderedSetOrdering"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}array\0\u{1}contents\0")

  public var isInitialized: Bool {
    if self._array == nil {return false}
    if self._contents == nil {return false}
    if let v = self._array, !v.isInitialized {return false}
    if let v = self._contents, !v.isInitialized {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._array) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._contents) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._array {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._contents {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OrderedSetOrdering, rhs: OrderedSetOrdering) -> Bool {
    if lhs._array != rhs._array {return false}
    if lhs._contents != rhs._contents {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OrderedSetOrderingArray: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "OrderedSetOrderingArray"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}contents\0\u{1}attachment\0")

  public var isInitialized: Bool {
    if self._contents == nil {return false}
    if let v = self._contents, !v.isInitialized {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.attachment) {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._contents) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.attachment) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._contents {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.attachment.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.attachment, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OrderedSetOrderingArray, rhs: OrderedSetOrderingArray) -> Bool {
    if lhs._contents != rhs._contents {return false}
    if lhs.attachment != rhs.attachment {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OrderedSetOrderingArrayAttachment: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "OrderedSetOrderingArrayAttachment"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}index\0\u{1}uuid\0")

  public var isInitialized: Bool {
    if self._index == nil {return false}
    if self._uuid == nil {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self._index) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self._uuid) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._index {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._uuid {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OrderedSetOrderingArrayAttachment, rhs: OrderedSetOrderingArrayAttachment) -> Bool {
    if lhs._index != rhs._index {return false}
    if lhs._uuid != rhs._uuid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension List: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "List"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}list_entry\0")

  public var isInitialized: Bool {
    if !SwiftProtobuf.Internal.areAllInitialized(self.listEntry) {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.listEntry) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.listEntry.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.listEntry, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: List, rhs: List) -> Bool {
    if lhs.listEntry != rhs.listEntry {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ListEntry: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "ListEntry"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\u{2}id\0\u{1}details\0\u{3}additional_details\0")

  public var isInitialized: Bool {
    if self._id == nil {return false}
    if self._additionalDetails == nil {return false}
    if let v = self._id, !v.isInitialized {return false}
    if let v = self._details, !v.isInitialized {return false}
    if let v = self._additionalDetails, !v.isInitialized {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularMessageField(value: &self._id) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._details) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._additionalDetails) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._id {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._details {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._additionalDetails {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ListEntry, rhs: ListEntry) -> Bool {
    if lhs._id != rhs._id {return false}
    if lhs._details != rhs._details {return false}
    if lhs._additionalDetails != rhs._additionalDetails {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ListEntryDetails: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "ListEntryDetails"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}list_entry_details_key\0\u{1}id\0")

  public var isInitialized: Bool {
    if let v = self._listEntryDetailsKey, !v.isInitialized {return false}
    if let v = self._id, !v.isInitialized {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._listEntryDetailsKey) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._id) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._listEntryDetailsKey {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._id {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ListEntryDetails, rhs: ListEntryDetails) -> Bool {
    if lhs._listEntryDetailsKey != rhs._listEntryDetailsKey {return false}
    if lhs._id != rhs._id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ListEntryDetailsKey: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "ListEntryDetailsKey"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}list_entry_details_type_index\0\u{3}list_entry_details_key\0")

  public var isInitialized: Bool {
    if self._listEntryDetailsTypeIndex == nil {return false}
    if self._listEntryDetailsKey == nil {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self._listEntryDetailsTypeIndex) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self._listEntryDetailsKey) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._listEntryDetailsTypeIndex {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._listEntryDetailsKey {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ListEntryDetailsKey, rhs: ListEntryDetailsKey) -> Bool {
    if lhs._listEntryDetailsTypeIndex != rhs._listEntryDetailsTypeIndex {return false}
    if lhs._listEntryDetailsKey != rhs._listEntryDetailsKey {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
